#
# -- Replay Scripts Export
#
# Generalized format per rc file:
#  * Metadata
#  * <ruby> section with the session attributes
#  * use {exploit module from session}
#  * set {various datastore options}
#  * run/exploit
#
# Note: the generated files are suitable for use in Metasploit Framework,
# without requiring access to Pro.
#
module Metasploit::Pro::Export::Type::ReplayScripts

  def description
    'A zip archive containing .rc text files describing each session in
the project. These may be used to verify attacks by attempting to
re-gain sessions with the same hosts, settings, etc.'
  end
  module_function :description

  def pretty_name
    'Replay Scripts'
  end
  module_function :pretty_name

  # Wrapper for all steps of a Replay Scripts export
  #
  def generate_replay_scripts_zip
    self.prepare!
    zip_path = self.file_path
    zip_name = File.basename(zip_path, '.zip')
    zip_dir = File.join(File.dirname(zip_path), zip_name)
    FileUtils.rm_rf(zip_dir) && Dir.mkdir(zip_dir)
    logger.debug("#{self.etype.pretty_name} zip file #{zip_path} will be created from #{zip_dir}")

    self.generate!
    # Create all the rc files in the directory to be zipped
    add_sessions_rc_files(zip_dir)

    begin
      create_zip_file(zip_path, zip_dir)
    rescue SystemCallError
      self.abort!
      logger.error "Problem creating zip file, directory not removed."
    end

    self.cleanup!
    FileUtils.rm_rf(zip_dir)

    self.complete!
    logger.info "#{self.etype.pretty_name} export completed in #{export_duration.round(3)}s"
  end

  # Generate rc files for each applicable session in workspace.
  # @param dir [String] path to directory in which to add .rc files
  def add_sessions_rc_files(dir)
    # TODO Verify what this number should be.
    # The old code looked like it meant to create 1-indexed sequential
    # count. The numbers in the actual filenames were not sequential,
    # however, nor did they match session ID, which might also make
    # sense. Now they are simply a 1-indexed sequence:
    rc_count = 1

    # Create an rc file per suitable session:
    self.workspace.sessions.each do |session|
      # Session must have an allowed host and a datastore
      next unless session.datastore
      next unless (session.host && session.host.address)
      host = session.host
      next unless host_allowed?(host)

      file_name = "session_#{rc_count}_#{host.address}.rc"
      file_path = File.join(dir, file_name)

      file_content = replay_summary(host, session)
      file_content << datastore_settings(session)

      # Appropriate command to fire it off:
      file_content << case session.via_exploit
                        when /exploit\//
                          "exploit\n"
                        else
                          "run\n"
                      end

      # Write out the rc file
      File.open(file_path, 'w') {|f| f.write(file_content)}
      # Iterate manually since we have to skip some sessions:
      rc_count += 1
    end
  end


  # High level information about session, YAML representation of details
  # @param host [Mdm::Host]
  # @param session [Mdm::Session]
  # @return [String]
  def replay_summary(host, session)
    %Q|#
# This replay script was generated by #{License.get.product_type} at #{Time.now.to_s} by #{self.created_by}
#
<ruby>
=begin
Target System: #{host.address}
 Exploit Used: #{session.via_exploit}
    Timestamp: #{session.opened_at}

Session Event Information
================================================================================
    #{session.to_yaml}
================================================================================
=end
</ruby>

# Start the replay process
use #{session.via_exploit}
|
  end

  # Set certain datastore options
  # @param session [Mdm::Session]
  # @return [String]
  def datastore_settings(session)
    settings = ''
    session.datastore.each_pair do |k, v|
      next if v.blank?
      # Legacy: These are skipped
      skip_keys = %w{WORKSPACE PROUSER MODULE_OWNER
                     VERBOSE REALLY_VERBOSE
                     WHITELIST_HOSTS BLACKLIST_HOSTS
                     PAYLOAD LHOST LPORT}
      next if skip_keys.include? k
      settings << "set #{k} #{v}\n"
    end
    settings
  end

end
