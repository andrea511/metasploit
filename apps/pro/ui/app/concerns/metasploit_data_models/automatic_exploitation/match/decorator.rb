module MetasploitDataModels::AutomaticExploitation::Match::Decorator
  extend ActiveSupport::Concern

  included do
    #
    # Associations
    #

    # @!attribute match_results
    #   The record of what happened when the system attempted the exploit described by #module_detail
    #
    #   @return [ActiveRecord::Relation<MetasploitDataModels::AutomaticExploitation::MatchResult>]
    has_many :match_results, class_name: "MetasploitDataModels::AutomaticExploitation::MatchResult", foreign_key: :match_id

    # @!attribute match_set
    #   The {MatchSet} that this {Match} is a part of
    #
    #   @return [ActiveRecord::Relation<AutomaticExploitation::MatchSet>]
    belongs_to :match_set, class_name: "MetasploitDataModels::AutomaticExploitation::MatchSet"

    # @!attribute nx_exploit
    #   The Nexpose-sourced exploit data associated with this {Match}
    #
    #   @return [Nexpose::Data::Exploit]
    belongs_to :nx_exploit, class_name: "Nexpose::Data::Exploit", foreign_key: :nexpose_data_exploit_id

    #
    # Scopes
    #

    scope :matches_to_console_and_vuln,
          lambda {
            match_table          = self.arel_table
            vuln_table           = Mdm::Vuln.arel_table
            vuln_to_console_join = Mdm::Vuln.joins(host: {nexpose_asset: {site: {import_run: :console}}}).arel
            vuln_join            = match_table.join(vuln_table).on(match_table[:matchable_type].eq("Mdm::Vuln").
                                                                     and(match_table[:matchable_id].eq(vuln_table[:id])))

            self.joins(vuln_join.join_sources, vuln_to_console_join.join_sources)
          }

    scope :failed_match_results,
          -> {joins(:match_results).where(automatic_exploitation_match_results: {state: "failed"})}


    scope :by_console_and_vuln_ids,
          lambda {|console_id, vuln_ids|
            self.matches_to_console_and_vuln.where(nexpose_consoles: {id: console_id}, matchable_id: vuln_ids)
          }

    scope :by_match_set_id,
          lambda {|match_set_id|
            self.joins(match_set: :runs).where(match_set_id:match_set_id)
          }

    scope :for_vuln_and_module_fullname,
          ->(vuln, fullname){where(matchable_id: vuln.id, module_fullname: fullname).limit(1)}

    scope :by_vuln_id,
          -> (vuln_id){self.where(matchable_type:"Mdm::Vuln", matchable_id: vuln_id)}

  end

  #
  # Instance Methods
  #

  # Returns the Nexpose-sourced definition of the vulnerability if this {Match} is for an {Mdm::Vuln}
  # @return [Nexpose::Data::VulnerabilityDefinition]
  def vuln_def
    if (matchable.is_a? Mdm::Vuln)
      matchable.nexpose_vulnerability_definition
    end
  end
end
