module MetasploitDataModels::AutomaticExploitation::MatchSet::Decorator
  extend ActiveSupport::Concern

  included do

    # Default MSF module ranking to use when creating matches
    DEFAULT_MSF_MODULE_RANK = Mdm::Module::Detail::RANK_BY_NAME['Great']

    # Create MatchSet and Match objects for a given array of Mdm::Vuln objects,
    # working with associated ::Nexpose::Data::Exploit objects to find Mdm::Module::Detail.
    # Filter to exclude "passive" stance.
    #
    # @param[Array<Mdm::Vuln>] the Vulns you are working with
    # @param[Hash] args further arguments used to make the MatchSet
    # @option args [String] :minimum_module_rank @see keys for Mdm::Module::Detail::RANK_BY_NAME.
    #   defaults to DEFAULT_MSF_MODULE_RANK.
    # @option args [Mdm::Workspace] :workspace
    # @option args [Mdm::User] :user
    #
    # @return[void]
    def self.create_with_matches_for_vulns(vulns, args={})
      match_set           = new
      match_set.workspace = args.fetch :workspace
      match_set.user      = args.fetch :user
      rank_symbol         = (args[:minimum_module_rank] || '').capitalize
      minimum_rank        = Mdm::Module::Detail::RANK_BY_NAME[rank_symbol] || DEFAULT_MSF_MODULE_RANK

      transaction do
        vulns.each do |vuln|
          runnable_exploits = vuln.nexpose_vulnerability_definition.exploits.metasploit_exploits
          next unless runnable_exploits.present?
          runnable_exploits.each do |exploit|
            module_detail = exploit.corresponding_mdm_record
            if exploit.present? && module_detail.present? && module_detail.aggressive? && module_detail.rank >= minimum_rank
              match_set.matches.build({
                                        matchable:               vuln,
                                        module_fullname:         module_detail.fullname,
                                        nexpose_data_exploit_id: exploit.id,
                                      })
            else
              next # There's no aggressive-stance Metasploit-sourced exploit in this record, so we move on
            end
          end
        end
        match_set.save
        match_set
      end
    end

    # Create a Match object for a given Mdm::Vuln
    # working with associated ::Nexpose::Data::Exploit objects to find a specific Mdm::Module::Detail
    # Filter to exclude "passive" stance.
    #
    # @param[Mdm::Vuln] the Vuln we want to create a match for
    # @param[Hash] args further arguments used to make the Match
    # @option args [String] :module_fullname the Mdm::Module::Detail we want to create a match for
    #
    # @return[Metasploit::Data::Models::AutomaticExploitation::Match]
    def create_match_for_vuln(vuln,args={})
      match_set = self
      match = nil

      # DEPRECATION WARNING: Using `return`, `break` or `throw` to exit a transaction block is
      # deprecated without replacement. If the `throw` came from
      # `Timeout.timeout(duration)`, pass an exception class as a second
      # argument so it doesn't use `throw` to abort its block. This results
      # in the transaction being committed, but in the next release of Rails
      # it will rollback.
      transaction do
        if vuln.nexpose_vulnerability_definition.present?
          runnable_exploits = vuln.nexpose_vulnerability_definition.exploits.metasploit_exploits

          if runnable_exploits.present?
            match = nil
            runnable_exploits.each do |exploit|
              module_detail = exploit.corresponding_mdm_record

              if exploit.present? && module_detail.aggressive? && args[:module_fullname] == module_detail.fullname && match.nil?
                match = match_set.matches.build({
                                                  matchable:               vuln,
                                                  module_fullname:         module_detail.fullname,
                                                  nexpose_data_exploit_id: exploit.id,
                                                })
                match_set.save
              else
                next # There's no aggressive-stance Metasploit-sourced exploit in this record, so we move on
              end
            end
          end
        end
      end
      match
    end

  end
end
