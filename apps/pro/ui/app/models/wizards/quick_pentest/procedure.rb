# The Wizards::QuickPentest::Procedure strings together some tasks:
#  1. Create workspace (done before module run)
#  2. Discovery scan/Nexpose scan/Import hosts
#  3. [Optional] Exploit hosts
#  4. [Optional] Collect evidence
#  5. [Optional] Generate report
# It also adds some nice custom logic in between these tasks
#  like filtering collected hosts by OS type, etc.
class Wizards::QuickPentest::Procedure < Wizards::BaseProcedure
  # todo kill with fire, see VulnValidation::Procedure
  # Run our state transitions OUTSIDE of transaction block
  include AfterCommitQueue

  # Lets make this public so that we don't need to call .send in
  #  our after_transition callbacks.
  # Allows us to run logic in an after_transition callback that
  #  escapes the implicit transaction involved in running transition
  #  events.
  public :run_after_commit

  #
  # Constants
  #
  # used to identify Unix-ish servers
  UNIXY_OSES = %w(linux sunos bsd solaris hpux hp-ux unix vax aix as400 darwin irix)
  UNIXY_SERVICES = %w(ssh inetd)

  #
  # State Machine
  #
  # actual logic of the wizard lives here
  state_machine :state, :initial => :ready do

    after_transition any => :scanning do |wizard, transition|
      wizard.run_after_commit do
        wizard.commander.run_module 'auxiliary/pro/discover', wizard.config_hash[:scan_task]
      end
    end

    after_transition any => :importing do |wizard, transition|
      wizard.run_after_commit do
        wizard.commander.run_module 'auxiliary/pro/import', wizard.config_hash[:import_task]
      end
    end

    after_transition any => :nexpose_scanning do |wizard, transition|
      wizard.run_after_commit do
        wizard.commander.run_module 'auxiliary/pro/nexpose', wizard.config_hash[:nexpose_task]
      end
    end

    after_transition any => :exploiting do |wizard, transition|
      # filter hosts and then kick off an exploit run
      wizard.run_after_commit do
        wizard.filter_hosts_in_config(wizard.config_hash[:exploit_task])
        wizard.commander.run_module 'auxiliary/pro/exploit', wizard.config_hash[:exploit_task]
      end
    end

    after_transition any => :collecting_evidence do |wizard, transition|
      wizard.run_after_commit do
        wizard.filter_hosts_in_config(wizard.config_hash[:collect_evidence_task])
        wizard.filter_sessions_in_config(wizard.config_hash[:collect_evidence_task])
        wizard.commander.run_module 'auxiliary/pro/collect', wizard.config_hash[:collect_evidence_task]
      end
    end

    after_transition [:exploiting, :collecting_evidence] => :cleaning_up do |wizard, transition|
      wizard.run_after_commit do
        wizard.filter_hosts_in_config(wizard.config_hash[:cleanup_task])
        wizard.filter_sessions_in_config(wizard.config_hash[:cleanup_task])
        wizard.commander.run_module 'auxiliary/pro/cleanup', wizard.config_hash[:cleanup_task]
      end
    end

    after_transition any => :reporting do |wizard, transition|
      wizard.run_after_commit do
        report = Report.find(wizard.config_hash[:report_id])
        report.generate_delayed
      end
    end

    after_transition [:scanning, :importing, :nexpose_scanning] => :finished do |wizard, transition|
      if !(wizard.send("matching_hosts").exists?)
        wizard.commander.print_error "Canceled Further Action: No Hosts Found"
      end
    end

    # build a map of state -> state for the next! event
    event :next do
      transition :ready => :scanning, :if => :assets_from_scan?
      transition :ready => :importing, :if => :assets_from_import?
      transition :ready => :nexpose_scanning, :if => :assets_from_nexpose?
      transition :ready => :finished
      transition [:scanning, :importing, :nexpose_scanning] => :exploiting, :if => :should_exploit?
      transition [:scanning, :importing, :nexpose_scanning] => :reporting, :if => :should_report?
      transition [:scanning, :importing, :nexpose_scanning] => :finished
      transition :exploiting => :collecting_evidence, :if => :should_collect_evidence?
      transition [:exploiting, :collecting_evidence] => :cleaning_up, :if => :should_cleanup?
      transition [:exploiting, :collecting_evidence, :cleaning_up] => :reporting, :if => :should_report?
      transition [:exploiting, :collecting_evidence, :cleaning_up] => :finished
      transition :reporting => :finished
    end

    event :error_occurred do |error_str|
      transition any => :error
    end
  end

  # Returns true if the assets to be acted on in the procedure
  # are to come from a scan of a live network.
  # @return [Boolean]
  def assets_from_scan?
    config_hash[:scan_type].to_s.to_sym == :regular_scan
  end

  # Returns true if the assets to be acted on in the procedure
  # come from an import task.
  # @return [Boolean]
  def assets_from_import?
    config_hash[:scan_type].to_s.to_sym == :import
  end

  # Returns true if the assets to be acted on in the procedure
  # come from a Nexpose task.
  # @return [Boolean]
  def assets_from_nexpose?
    config_hash[:scan_type].to_s.to_sym == :nexpose_scan
  end

  # Returns true if the system should run the collect evidence module,
  # which will run multiple scripts to gather passwords, screenshots,
  # dump hashes, etc on compromised systems, via combination of Meterpreter-based scripts
  # and auxiliary modules.
  # @return [Boolean]
  def should_collect_evidence?
    config_hash[:collect_evidence]
  end

  # Change running config to only target specific hosts
  # @param [Hash] config the config object which will be passed to the tasks
  def filter_hosts_in_config(config)
    return unless config.present?
    config['DS_WHITELIST_HOSTS'] = matching_hosts.pluck(:address).uniq.join(' ')
  end

  # Change running config to target open sessions in the workspace
  # @param [Hash] config the config object which will be passed to the tasks
  def filter_sessions_in_config(config)
    return unless config.present?
    workspace.sessions.alive.each do |session|
      config['DS_SESSIONS'] << "#{session.local_id.to_s} "
    end
  end

  # Helper for returning the profile as a symbol
  # @return [Symbol] representing the profile
  def profile
    (config_hash[:profile] || '').to_sym
  end

  # Helper for state_machine transition condition
  # @return [Boolean] that determines whether to run the exploit
  #   task, or skip to :finished
  def should_exploit?
    config_hash[:exploit_enabled] and matching_hosts.exists?
  end

  # Helper for state_machine transition conditions
  # @return [Boolean] whether we should generate a report
  def should_report?
    config_hash[:report_enabled] and workspace.hosts.exists?
  end

  # Helper for state_machine transition condition
  # Checks for a user selected cleanup task and
  # whether there are active sessions in the workspace
  # @return [Boolean] whether we should run cleanup
  def should_cleanup?
    config_hash[:cleanup_enabled] and workspace.sessions.alive.exists?
  end

  private

  # Helper that grabs hosts in the current workspace that
  #   match the :profile type.
  # @return [ActiveRelation] containing Mdm::Hosts that match the profile
  def matching_hosts
    case profile
      when :everything
        workspace.hosts
      when :windows
        workspace.hosts.where("lower(os_name) ILIKE '%windows%'")
      when :unix_servers
        find_unixy_servers
      when :web_servers
        # look for a http or https service in the given workspace
        svcs = Mdm::Service.where("lower(services.name) ILIKE '%http%'")
        workspace.hosts.where('id IN (?)', svcs.pluck(:host_id))
      when :network_devices
        workspace.hosts.where(:purpose => "device")
      else
        workspace.hosts
    end
  end

  # @return [ActiveRelation] that targets hosts with Unix-y OSes or running
  #   Unix-y services
  def find_unixy_servers
    # match via OS name
    unixy_os = Wizards::QuickPentest::Procedure::UNIXY_OSES
    clause = unixy_os.map{ |os| "os_name ILIKE '%#{os}%'" }.join " OR "
    unix_hosts_by_os = workspace.hosts.where(clause).pluck(:id)
    # match via Service name
    unixy_svcs = Wizards::QuickPentest::Procedure::UNIXY_SERVICES
    clause = unixy_svcs.map{ |svc| "services.name ILIKE '%#{svc}%'" }.join " OR "
    unix_hosts_by_service = Mdm::Service.where(clause).pluck(:host_id)
    # combine into one query with an OR
    workspace.hosts.where("id IN (?) OR id in (?)", unix_hosts_by_os, unix_hosts_by_service)
                   .where(:purpose => "server")            # don't hit devices with ssh!
                   .where("os_name NOT ILIKE '%windows%'") # ensure we never attack windows hosts
  end
end
