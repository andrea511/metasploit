# This class represents Nexpose's notion of an exploit's metadata and is used to
# implement a Nexpose-side dictionary of software which is known to be able to exploit
# particular vulnerabilities tracked by Nexpose.
#
# Nexpose tracks exploits that exist in Metasploit with an identifying string of "metasploit".
class ::Nexpose::Data::Exploit < ApplicationRecord
  METASPLOIT_SOURCE_IDENTIFIER  = "metasploit"
  METASPLOIT_EXPLOIT_IDENTIFIER = "exploit"

  #
  # Associations
  #


  # @!attribute module_detail
  #   The Metasploit identifier for this exploit
  #
  #   @return [Mdm::ModuleDetail]
  belongs_to :module_detail,
             class_name:  "Mdm::Module::Detail",
             foreign_key: 'source_key',
             primary_key: 'fullname',
             optional: true,
             inverse_of:  :nexpose_data_exploits

  # @!attribute vulnerability_definitions
  #   The vulnerabilities that Nexpose associates with this exploit
  #
  #   @return [ActiveRecord::Relation<Nexpose::Data::VulnerabilityDefinition>]
  has_and_belongs_to_many :vulnerability_definitions,
                          :class_name => "::Nexpose::Data::VulnerabilityDefinition",
                          :join_table => "nexpose_data_exploits_vulnerability_definitions"


  #
  # Scopes
  #
  scope :exploit_id, lambda {|exploit_id| where(:nexpose_exploit_id => exploit_id.to_s)}
  scope :metasploit_exploits, lambda { where("source = ? AND source_key ILIKE ?", METASPLOIT_SOURCE_IDENTIFIER, "%#{METASPLOIT_EXPLOIT_IDENTIFIER}%") }

  #
  # Rails 4 compatibility, manually create accessible attributes
  #
  ACCESSIBLE_ATTRS = [
    'description',
    'module_detail_id',
    'nexpose_exploit_id',
    'skill_level',
    'source',
    'source_key'
  ]

  # A Ruby representation of the object retrieved from the Nexpose API
  # @param object_attributes [Hash] the deserialized JSON
  # @return [Nexpose::Data::ScanTemplate]
  def self.object_from_json(object_attributes)
    exploit_attributes = object_attributes.slice(*ACCESSIBLE_ATTRS)

    exploit = self.exploit_id(object_attributes["exploit_id"]).
      first_or_create(exploit_attributes)
    exploit
  end

  # The Metasploit data construct that corresponds to this exploit's info
  # @return[Mdm::Module::Detail]
  def corresponding_mdm_record
    fail "not a Metasploit exploit" unless metasploit_sourced?
    Mdm::Module::Detail.find_by_fullname(source_key)
  end

  # true if the exploit source_key starts with 'exploit', as in 'exploit/multi/samba/usermap_script'
  # @return[Boolean]
  def metasploit_exploit?
    metasploit_sourced? && source_key.starts_with?(METASPLOIT_EXPLOIT_IDENTIFIER)
  end

  # true if the exploit source is Metasploit
  # @return[Boolean]
  def metasploit_sourced?
    source == METASPLOIT_SOURCE_IDENTIFIER
  end

end
