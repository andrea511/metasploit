class ExploitTask < TaskConfig
  include Metasploit::Pro::AttrAccessor::Boolean

  RANKS = ["low", "average", "normal", "good", "great", "excellent"].map{|x| x.capitalize }
  NUMERIC_RANKS = (100..600).step(100)
  CONNECTIONS = ["auto", "reverse", "bind"].map{|x| x.capitalize }
  PAYLOAD_TYPES = ["Meterpreter", "Meterpreter 64-bit", "Command shell", "Powershell"]
  EVASION_LEVELS_LABELS = ["None", "Low", "Medium", "High"]
  EVASION_LEVELS = (0..EVASION_LEVELS_LABELS.size-1).to_a
  SPEEDS = (1..10).to_a

  attr_accessor :whitelist, :blacklist, :minimum_rank, :speed, :timeout

  attr_accessor :connection, :payload_type, :payload_ports, :payload_lhost

  attr_accessor :limit_sessions, :ignore_fragile_devices, :filter_by_os, :only_match
  attr_accessor :whitelist_ports, :blacklist_ports
  attr_accessor :filter_by_vuln, :filter_by_port
  attr_accessor :evasion_level_tcp, :evasion_level_app
  attr_accessor :module_filter
  attr_accessor :macro_name
  attr_accessor :http_username, :http_password, :http_domain, :cookie, :user_agent
  attr_accessor :dynamic_stager

  # @attribute! [r] max_threads
  # Only applies when running Vuln Validation Commander
  # @return [Integer] number of modules to run concurrently
  attr_reader :max_threads

  # skips the validation for IP addresses passed in
  attr_accessor :skip_host_validity_check

  boolean_attr_accessor :stage_encoding, :default => false

  def initialize(attributes)
    super(attributes)

    @whitelist = attributes[:whitelist] || []
    @blacklist = attributes[:blacklist] || []
    @minimum_rank = attributes[:minimum_rank] || "Great"
    @speed = (attributes[:speed] || 5).to_i
    @timeout = (attributes[:timeout] || 5).to_i

    @connection = attributes[:connection] || "Auto"
    @payload_type = attributes[:payload_type] || "Meterpreter"
    @payload_ports = attributes[:payload_ports] || "1024-65535"
    @payload_lhost = attributes[:payload_lhost]
    @payload_lhost = nil if @payload_lhost.to_s.strip.empty?
    @max_threads = attributes[:max_threads] || 5

    @limit_sessions = set_default_boolean(attributes[:limit_sessions], true)
    @ignore_fragile_devices = set_default_boolean(attributes[:ignore_fragile_devices], true)
    @filter_by_os = set_default_boolean(attributes[:filter_by_os], false)
    @only_match = set_default_boolean(attributes[:only_match], false)
    @whitelist_ports = port_fixup(attributes[:whitelist_ports] || "1-65535")
    @blacklist_ports = port_fixup(attributes[:blacklist_ports] || "")

    @whitelist = tags_and_addresses(@whitelist)
    @blacklist = tags_and_addresses(@blacklist)
    @evasion_level_tcp = (attributes[:evasion_level_tcp] || 0).to_i
    @evasion_level_app = (attributes[:evasion_level_app] || 0).to_i

    if attributes[:whitelist_string]
      @whitelist = tags_and_addresses(attributes[:whitelist_string].split(/\s+/))
    end

    if attributes[:blacklist_string]
      @blacklist = tags_and_addresses(attributes[:blacklist_string].split(/\s+/))
    end

    @filter_by_vuln = set_default_boolean(attributes[:filter_by_vuln], true)
    @filter_by_port = set_default_boolean(attributes[:filter_by_port], true)

    @module_filter = attributes[:modules] || []

    @macro_name = attributes[:macro_name] || ""

    @http_username = attributes[:http_username] || ''
    @http_password = attributes[:http_password] || ''
    @http_domain   = attributes[:http_domain]   || ''
    @cookie = attributes[:cookie] || ''
    @user_agent = attributes[:user_agent] || "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)"
    @skip_host_validity_check = set_default_boolean(attributes[:skip_host_validity_check], false)
    @dynamic_stager = attributes.fetch(:dynamic_stager, true)
  end

  def whitelist_string
    whitelist.join("\n")
  end

  def blacklist_string
    blacklist.join("\n")
  end

  def port_fixup(str)
    str.split("\n").map{|x| x.strip}.join(",")
  end

  def matching_modules
    min_numeric_rank = NUMERIC_RANKS[RANKS.index(minimum_rank)]
    MsfModule.exploits.select {|m| m.rank >= min_numeric_rank }.select {|m| m.server_exploit? and not m.file_format_exploit? }.sort_by(&:title)
  end

  def valid?
    unless @skip_host_validity_check
      # Validate address space
      if whitelist.nil? or whitelist.empty?
        @error = "At least one IP address is required"
        return false
      end

      whitelist.each do |ip|
        next if valid_ip_or_range?(ip)
        @error = "Invalid target IP address: #{ip}"
        return false
      end

      unless @workspace.allow_actions_on?(whitelist.join(" "))
        @error = "Target Addresses must be inside workspace boundaries"
        return false
      end
    end

    blacklist.each do |ip|
      next if valid_ip_or_range?(ip)
      @error = "Invalid excluded IP address: #{ip}"
      return false
    end

    # Validate Rank
    if !RANKS.include? minimum_rank
      @error = "Invalid Reliability: #{minimum_rank}"
      return false
    end

    # Validate Speed
    if !SPEEDS.include? speed.to_i
      @error = "Invalid Concurrency: #{speed}"
      return false
    end

    # Validate Timeout
    if timeout.to_f < 0.1 # Allow a six second timeout.
      @error = "Invalid Timeout: #{timeout}"
      return false
    end

    # Validate Ports
    if @whitelist_ports and !@whitelist_ports.empty?
      @whitelist_ports = @whitelist_ports.split(/[,|\s]+/).join ',' # normalize commas and whitespace into csv
      unless @whitelist_ports =~ /^[0-9,\x2d]+$/
        @error = "Invalid Included Ports: #{@whitelist_ports}"
        return false
      end
    end

    if @blacklist_ports and !@blacklist_ports.empty?
      @blacklist_ports = @blacklist_ports.split(/[,|\s]+/).join ',' # normalize commas and whitespace into csv
      unless @blacklist_ports =~ /^[0-9,\x2d]+$/
        @error = "Invalid Excluded Ports: #{@blacklist_ports}"
        return false
      end
    end

    # Validate payload type
    if !PAYLOAD_TYPES.include? payload_type
      @error = "Invalid payload type: #{payload_type}"
      return false
    end

    # Validate payload connection
    if !CONNECTIONS.include? connection
      @error = "Invalid Connection Type: #{connection}"
      return false
    end

    # Validate payload listener ports
    r = Rex::Socket.portspec_crack(payload_ports) rescue []
    if r.length == 0
      @error = "Invalid Payload Ports: #{payload_ports}"
      return false
    end

    # Validate payload listener host override
    if payload_lhost and not valid_ip_or_range?(payload_lhost)
      @error = "Invalid Payload Mdm::Listener Address: #{payload_lhost}"
      return false
    end

    # Validate the evasion levels
    if evasion_level_tcp and !(EVASION_LEVELS.include? evasion_level_tcp.to_i)
      @error = "Transport evasion level must be one of #{EVASION_LEVELS.join(', ')}, not #{evasion_level_tcp.inspect}"
      return false
    end

    if evasion_level_app and !(EVASION_LEVELS.include? evasion_level_app.to_i)
      @error = "Application evasion level must be one of #{EVASION_LEVELS.join(', ')}, not #{evasion_level_tcp.inspect}"
      return false
    end

    if not @macro_name.strip.to_s.empty?
      if not ::Mdm::Macro.find_by_name(@macro_name)
        @error = "Invalid Mdm::Macro Name"
        return false
      end
    end

    # If you've gotten this far, you're valid.
    @error = nil
    return true
  end

  def config_to_hash
    conf = {
        'DS_WHITELIST_HOSTS'      => whitelist.join(" "),
        'DS_BLACKLIST_HOSTS'      => blacklist.join(" "),
        'DS_WHITELIST_PORTS'      => whitelist_ports,
        'DS_BLACKLIST_PORTS'      => blacklist_ports,
        'DS_MinimumRank'          => minimum_rank.downcase,
        'DS_EXPLOIT_SPEED'        => speed.to_i,
        'DS_EXPLOIT_TIMEOUT'      => timeout.to_i,
        'workspace'               => workspace.name,
        'username'                => username,
        'DS_LimitSessions'        => limit_sessions,
        'DS_IgnoreFragileDevices' => ignore_fragile_devices,
        'DS_FilterByOS'           => filter_by_os,
        'DS_OnlyMatch'            => only_match,
        'DS_MATCH_VULNS'          => filter_by_vuln,
        'DS_MATCH_PORTS'          => filter_by_port,
        'DS_PAYLOAD_METHOD'       => connection.downcase,
        'DS_PAYLOAD_TYPE'         => payload_type.downcase,
        'DS_PAYLOAD_PORTS'        => payload_ports,
        'DS_EVASION_LEVEL_TCP'    => evasion_level_tcp,
        'DS_EVASION_LEVEL_APP'    => evasion_level_app,
        'DS_ModuleFilter'         => module_filter.join(","),
        'DS_HTTPCookie'           => cookie,
        'DS_USERNAME'             => http_username,
        'DS_PASSWORD'             => http_password,
        'DS_UserAgent'            => user_agent,
        'DS_DOMAIN'               => http_domain,
        'DS_MAX_THREADS'          => max_threads,
        'DS_DynamicStager'        => dynamic_stager,
        'DS_EnableStageEncoding'  => stage_encoding?
    }

    if current_profile && current_profile.settings['payload_prefer_https']
      conf['DS_EnableReverseHTTPS'] = true
    end

    if current_profile && current_profile.settings['payload_prefer_http']
      conf['DS_EnableReverseHTTP'] = true
    end

    if not macro_name.to_s.empty?
      conf['DS_AutoRunScript'] = "post/pro/multi/macro MACRO_NAME='#{macro_name}'"
    end

    conf['DS_PAYLOAD_LHOST'] = payload_lhost if payload_lhost
    conf
  end

  def rpc_call
    client.start_exploit(config_to_hash)
  end

  def allows_replay?
    true
  end
end

