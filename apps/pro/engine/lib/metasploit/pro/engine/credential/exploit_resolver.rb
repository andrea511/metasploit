module Metasploit
  module Pro
    module Engine
      module Credential

        # This class is responsible for consuming one or more `Metamodule_for::Credential::Login` objects
        # and resolving them to a series of Exploit Modules that are properly configured to try and
        # get a `Session` on those `Mdm::Service`s with those credentials.
        class ExploitResolver
          include ActiveModel::Validations

          # @!attribute framework
          #   @return [Msf::Framework] The framework instance to build the modules from
          attr_accessor :framework

          # @!attribute login_ids
          #   @return [Activerecord::Relation] The login_ids that we are resolving for
          attr_accessor :login_ids

          validates :framework, presence: true
          validates :login_ids, presence: true

          # @param attributes [Hash{Symbol => String,nil}]
          def initialize(attributes={})
            attributes.each do |attribute, value|
              public_send("#{attribute}=", value)
            end
          end

          # This method takes a block and yields each configured module that is found
          # for the Logins.
          #
          # @yieldparam [Msf::Module] a partially configured module for one `Metasploit::Credential::Login`
          # @return [void]
          def each_module
            valid!
            logins.each do |login|
              partially_configured_module = module_from_login(login)
              unless partially_configured_module.nil?
                yield partially_configured_module
              end
            end
          end

          # This method returns an {Activerecord::Relation} of the Logins specified
          # by the user supplied Login ids.
          #
          # @return [Activerecord::Relation]
          def logins
            @logins ||= Metasploit::Credential::Login.where(id: login_ids)
          end

          # This method takes a `Metasploit::Credential::Login` and determines
          # the correct module to run based on the `Mdm::Service`. It then configures
          # the module appropriately using the `Mdm::Service` and `Metasploit::Credential::Core`
          #
          # @param login [Metasploit::Credential::Login]
          # @return [Msf::Module] if a module was found that could get shell
          # @return [nil] if no module was found
          def module_from_login(login)
            raise ArgumentError, "Argument must be a Metaslpoit::Credential::Login" unless login.kind_of? Metasploit::Credential::Login

            service    = login.service
            host       = service.host

            return nil unless ::Mdm::Service::SHELLABLE_SERVICE_NAMES.include? service.name

            case service.name.downcase
              when /http/
                module_for_http(host,service,login)
              when 'mssql'
                module_for_mssql(host,service,login)
              when 'mysql'
                module_for_mysql(host,service,login)
              when 'postgres'
                module_for_postgres(host,service,login)
              when 'smb'
                module_for_smb(host,service,login)
              when 'ssh'
                module_for_ssh(host,service,login)
              when 'telnet'
                module_for_telnet(host,service,login)
              when 'winrm'
                module_for_winrm(host,service,login)
            end
          end

          def module_for_http(host,service,login)
            credential = login.core.to_credential
            case service.info
              when /Axis/i
                mod_name = "exploit/multi/http/axis2_deployer"
              when /Tomcat|Coyote/i
                mod_name = "exploit/multi/http/tomcat_mgr_deploy"
              when /GlassFish/
                mod_name = "exploit/multi/http/glassfish_deployer"
              else
                return
            end
            opts = {
                'RHOSTS'    => host.address,
                'RPORT'    => service.port,
                'USERNAME' => credential.public,
                'PASSWORD' => credential.private
            }

            # If this is https and not just http, set SSL on the module
            if service.name =~ /https/
              opts['SSL'] = true
            end
            build_module(mod_name,opts,login)
          end

          def module_for_mssql(host,service,login)
            credential = login.core.to_credential
            mod_name = "exploit/windows/mssql/mssql_payload"
            opts = {
                'RHOSTS'    => host.address,
                'RPORT'    => service.port,
                'USERNAME' => credential.public,
                'PASSWORD' => credential.private
            }
            if credential.realm
              opts['Domain'] = credential.realm
              opts['USE_WINDOWS_AUTHENT'] = true
            end
            build_module(mod_name,opts,login)
          end

          def module_for_mysql(host,service,login)
            return unless host.os =~ /Windows/i
            credential = login.core.to_credential
            mod_name = "exploit/multi/mysql/mysql_udf_payload"
            opts = {
                'RHOSTS'    => host.address,
                'RPORT'    => service.port,
                'USERNAME' => credential.public,
                'PASSWORD' => credential.private
            }
            build_module(mod_name,opts,login)
          end

          def module_for_postgres(host,service,login)
            credential = login.core.to_credential
            if host.os =~ /Windows/i
              mod_name = "exploit/windows/postgres/postgres_payload"
            else
              mod_name = "exploit/linux/postgres/postgres_payload"
            end
            opts = {
                'RHOSTS' => host.address,
                'RPORT' => service.port,
                'USERNAME' => credential.public,
                'PASSWORD' => credential.private
            }
            if credential.realm
              opts['DATABASE'] = credential.realm
            end
            build_module(mod_name,opts,login)
          end

          def module_for_smb(host,service,login)
            credential = login.core.to_credential
            mod_name = "exploit/windows/smb/psexec"
            opts = {
                'RHOSTS'   => host.address,
                'RPORT'   => service.port,
                'SMBUser' => credential.public,
                'SMBPass' => credential.private
            }
            if credential.realm
              opts['SMBDomain'] = credential.realm
            end
            build_module(mod_name,opts,login)
          end


          def module_for_ssh(host,service,login)
            credential = login.core.to_credential
            opts = {
              'RHOSTS'          => host.address,
              'RPORT'           => service.port,
              'BLANK_PASSWORDS' => false,
              'STOP_ON_SUCCESS' => true,
              'USER_AS_PASS'    => false,
              'USERNAME'        => credential.public
            }
            case credential.private_type
            when :password
              mod_name = "auxiliary/scanner/ssh/ssh_login"
              opts['PASSWORD'] = credential.private
            when :ssh_key
              mod_name = "auxiliary/scanner/ssh/ssh_login_pubkey"
              opts['PRIVATE_KEY'] = credential.private
            end
            build_module(mod_name, opts, login)
          end

          def module_for_telnet(host,service,login)
            credential = login.core.to_credential
            mod_name = "auxiliary/scanner/telnet/telnet_login"
            opts = {
                'RHOSTS'          => host.address,
                'RPORT'           => service.port,
                'USERNAME'        => credential.public,
                'PASSWORD'        => credential.private,
                'USERPASS_FILE'   => '',
                'USER_FILE'       => '',
                'PASS_FILE'       => '',
                'BLANK_PASSWORDS' => false,
                'STOP_ON_SUCCESS' => true,
                'USER_AS_PASS'    => false
            }
            build_module(mod_name,opts,login)
          end

          def module_for_winrm(host,service,login)
            credential = login.core.to_credential
            mod_name = "exploit/windows/winrm/winrm_script_exec"
            opts = {
                'RHOSTS' => host.address,
                'RPORT' => service.port,
                'USERNAME' => credential.public,
                'PASSWORD' => credential.private
            }
            if credential.realm
              opts['Domain'] = credential.realm
            end
            build_module(mod_name,opts,login)
          end

          # Raise an exception if this resolver's attributes are not valid.
          #
          # @raise [InvalidResolver] if the attributes are not valid on this resolver
          # @return [void]
          def valid!
            unless valid?
              raise InvalidResolver.new(self)
            end
            nil
          end

          private

          def build_module(name,opts,login)
            mod = framework.modules.create(name)
            mod.import_defaults
            mod.datastore.merge!(opts)
            mod.datastore['SOURCE_LOGIN_ID'] = login.id
            mod.options.validate(mod.datastore)
            mod
          end

        end

        # This class is an Exception class designed to be used when an {ExploitResolver}
        # is invalid. It contains all of the validation errors found on the {ExploitResolver}.
        class InvalidResolver  < StandardError
          attr_reader :model

          def initialize(model)
            @model = model

            errors = @model.errors.full_messages.join(', ')
            super(errors)
          end
        end

      end
    end
  end
end
